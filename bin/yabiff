#!/usr/bin/wish
# yabiff.tcl
# Author: Bart Robinson <lomew@cs.utah.edu>
# Translated to Tcl: Anand Ranganathan <anand@cs.utah.edu>
# Reworked and added ssh connection support by Mike Demmer <mike@demmer.nu>

## XXX this should be in resources but I don't know how
set width 60
set delay 5
set fg black
set bg grey87
set font "6x10"
set default_geometry "=300x70+10+10"
set hosts ""
set checkfetch ""
set usebar 1
set beep 1

if {! [info exists geometry]} {
    set geometry $default_geometry
}    

array set argvars {
    -geometry		geometry
    -geom		geometry
    -delay		delay
    -host		hosts
    -checkfetch		checkfetch
    -bar		usebar
    -beep		beep
}

proc usage {} {
    global argvars
    puts -nonewline "usage: yabiff "
    foreach arg [array names argvars] {
	puts "\[ $arg \] "
    }
    puts ""
    exit 1
}

for {set i 0} {$i < [llength $argv]} {incr i} {
    set arg [lindex $argv $i]
    set val [lindex $argv [incr i]]
    if {! [info exists argvars($arg)]} {
	puts stderr "unknown argument $arg"
	usage
    }

    set $argvars($arg) $val
}

set hosts [split $hosts ,]
array set checkfetch_hosts {}
foreach h [split $checkfetch ,] {
    set checkfetch_hosts($h) 1
}

if [info exists env(USER)] {
    set user $env(USER);
} elseif [info exists env(LOGNAME)] {
    set user $env(LOGNAME);
} else {
    puts stderr "I don't believe we have met.";
    exit -1;
}

if {$hosts == ""} {
    # no host specified, look for a spoolfile
    if [info exists env(MAIL)] {
	if [file exists $env(MAIL)] {
	    set spoolfile $env(MAIL);
	}
    } elseif [file exists "/usr/spool/mail/$user"] {
	set spoolfile "/usr/spool/mail/$user";
    } elseif [file exists "/usr/mail/$user"] {
	set spoolfile "/usr/mail/$user";
    } elseif [file exists "/var/mail/$user"] {
	set spoolfile "var/mail/$user";
    } elseif [file exists "/var/spool/mail/$user"] {
	set spoolfile "/var/spool/mail/$user";
    }

    if [expr ! [info exists spoolfile]] {
	puts stderr "no spool";
	exit -1;
    }
}

wm title . YaBiff;
wm geometry . $geometry

if {$usebar} {
    set bar_width 2
    text .bar -wrap none -font $font \
	    -width $bar_width -background $bg -bd 1
    pack .bar -side left -expand no -fill y
} else {
    set bar_width 0
}

set g [split $geometry {=x+}]
set y [lindex $g 2]

if {$hosts == ""} {
    text $text -wrap none -font $font -background $bg -bd 1 -height 0
    pack $text -expand yes -fill both -side top 
} else {
    foreach host $hosts {
	set text ".text-$host"
	text $text -wrap none -font $font -background $bg -bd 1 -height 0
	pack $text -expand yes -fill both -side top 
    }
}

proc flash {} {
    global beep;
    global flash;
    global bg;
    global fg;
    if {$beep} {
	bell -displayof .;
    }
    if {$flash} {
	.text configure -foreground $bg -background $fg;
	after 200 .text configure -foreground $fg -background $bg;
    }
}

set ctime 0
proc checktime {} {
    global ctime
    global spoolfile
    if [file exists $spoolfile] {
	set newctime [file mtime $spoolfile]
	if {$newctime > $ctime} {
	    set ctime $newctime
	    return 1
	}
    }
    return 0
}

set nlines_total 0
proc refresh {host lines} {
    global fg bg beep usebar
    global nlines_total
    upvar \#0 nlines_$host nlines_host

    if {$host == ""} {
	set text .text
    } else {
	set text .text-$host
    }

    $text configure -state normal
    $text delete 0.0 end

    # adjust the global line count to tell if there's any new messages
    # in any window
    set nlines [llength $lines]
    if {![info exists nlines_host]} {
	set nlines_host 0
    }

    set old_nlines_total $nlines_total
    set nlines_total [expr $nlines_total - $nlines_host + $nlines]
    set nlines_host $nlines

    # don't put a newline after the last one
    $text insert 0.0 "[lindex $lines 0]"
    for {set i 1} {$i < $nlines} {incr i} {
	set line [lindex $lines $i]
	$text insert 0.0 "$line\n";
    }

    if {$beep && ($nlines_total > $old_nlines_total)} {
	bell -displayof .;
    }
    
    if {$usebar} {
	if {$nlines_total > 0} {
	    .bar configure -bg $fg
	} else {
	    .bar configure -bg $bg
	}
    }

    # make sure the bottom of the textbox is displayed
    $text yview moveto 1.0
    
    $text configure -state disabled
}

proc spoolfile_loop {} {
    global spoolfile
    global update_id
    global delay

    if [info exists update_id] {
	after cancel update_id
    }
    set update_id [after [expr $delay * 1000] update_spoolfile]

    set handle [open "|frm -s new -s unread" RDONLY];
    set lines {}
    while {! [eof $handle]} {
	gets $handle line
	lappend lines $line
    }
    catch {close $handle};
    
    refresh "" $lines
}

proc remote_loop {} {
    global hosts checkfetch_hosts delay

    set delay_arg "-delay $delay"

    foreach host $hosts {
	set checkfetch ""
	if {[info exists checkfetch_hosts($host)]} {
	    set checkfetch "-checkfetch "
	}
	set cmd "ssh -v $host yabiff-server $delay_arg $checkfetch < /dev/null"
	# puts "running $cmd"
	set ssh [open "|$cmd" r]
	fconfigure $ssh -blocking false -buffering none
	fileevent $ssh readable "update_remote $host $ssh"
    }
}

proc update_remote {host ssh} {
    set lines {}
    
    # something should be readable here
    set ret [gets $ssh line]
    if {$ret == -1} {
	refresh $host {"(error: ssh tunnel died)"}
	close $ssh
	return
    }
    
    # if it's a ping, just loop and block again
    if {$line == "ping"} {
	return
    }
    
    # otherwise, read until a line with a .
    while {$line != "."} {
	if {$line != ""} {
	    set lines [linsert $lines 0 $line]
	}
	
	gets $ssh line

	if {$line == ""} {
	    after 100
	}
    }
    
    # output what we got
    refresh $host $lines
}

if [info exists spoolfile] {
    spoolfile_loop
} else {
    remote_loop
}
